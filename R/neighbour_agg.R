#' Neighbouhood index Function - neighbour.agg
#' 
#' This function is an implementation of the Neighbourhood Index for quantifying wildfire likelihood.
#' For details, please see the publication Radford et al. (2024). An efficient, multi-scale neighbourhood index to quantify wildfire likelihood. The International Journal of Wildland Fire. DOI: 10.1071/WF23055.
#' @param x An input SpatRaster layer which describes the contribution of each cell to fire spread in a "neighbourhood" (e.g., potential Rate of Spread, Head Fire Intensity).
#' @param params A dataframe with input parameters, each corresponding to the number of "neighbourhoods". Three parameters required in the dataframe, Distance (param_D), Alpha (param_alpha) and Resolution Factors (param_Rfact).
#' @param wdir numeric giving the direction of prevailing wind, with respect to which neighbourhood aggregation should be calculated.
#' @param edge.value numeric (or NA) passed to terra's focal function (as fillvalue). The edge.value is used where neighbourhoods extend beyond the raster extent of input x. 
#' @param logmatrix Logical. Should the moving window(s) generated by the input parameter combination(s) be printed to the log folder? Defaults to F. Log folder will be generated in the working directory.
#' @keywords Neighbourhood
#' @export
#' @examples 
#' # Load some example input data (e.g., representing Rate of Spread)
#'   ROS <- rast(system.file("extdata/ROS.tif", package = "Firehoods"))
#'   
#' # Define a set of neighbourhood parameters to aggregate the inputs with:
#'   Neighbourhood_params <- data.frame(param_D = c(500, 2000, 5000, 10000), param_alpha = c(360, 180, 90, 15), param_Rfact = c(2,8,16,32))
#'   
#' # Aggregate input data using defined neighbourhoods and plot:
#'   NI <- neighbour.agg(x = ROS, params = Neighbourhood_params, wdir = 45.0, edge.value = NA, logmatrix = F)
#'   plot(NI)

neighbour.agg <- function(x, params, wdir, edge.value, logmatrix = F){
  
### Create Neighbourhoods to use in terra's focal function:
  
  ##Prepare matrices
    # Calculate the resolution of each layer as based on the Rfact adjustment.
      params$Res <- params$param_Rfact * terra::res(x)[1]
      
    # Calculate the size of each focal moving window required. This is a function of (1) the Distance parameter for each layer (measured in meters) and (2) the Res (resolution) of the input features for each layer, as adjusted for the Rfact.
      params$extent <- lapply(1:nrow(params), function(n){seq(-ceiling(params$param_D[n]/params$Res[n])*params$Res[n], ceiling(params$param_D[n]/params$Res[n])*params$Res[n],params$Res[n])})
        
    # Create a matrix of x-coordinates and a matrix of y-coordinates given the above required extent calculated.
      # These will form the basis of matrices to serve in terra's focal function. Each matrix has enough rows and columns for the distance parameter of each neighbourhood, 
      # noting that the matrix must be centered around the point of interest, with an odd number of rows and columns.
      params$x_coord <- lapply(1:nrow(params), function(n){matrix(data = rep(params$extent[[n]], length(params$extent[[n]])), nrow = length(params$extent[[n]]), ncol = length(params$extent[[n]]), byrow = T)})
      params$y_coord <- lapply(1:nrow(params), function(n){t(params$x_coord[[n]])})
    
  ## Calculate Distances
    # Use xy-coordinates to calculate distance from the point of interest to each cell in the matrix. This will be used to subset cells within neighbourhood based on the distance parameters.
      params$dist <- lapply(1:nrow(params), function(n){sqrt(params$x_coord[[n]]^2 + params$y_coord[[n]]^2)})
    
  ## Calculate angles 
    # Convert wind direction measured from "North" to radian measure from x-axis. 
      wdir_rad <- (-90+wdir)*pi/180.0
    
    #Rotate definition of xy-coordinates by the angle of the prevailing wind direction. This allows us to subset the cells based on angle relevant to wind direction.
      params$x_coord_rotated <- lapply(1:nrow(params), function(n){params$x_coord[[n]]*cos(wdir_rad)+params$y_coord[[n]]*sin(wdir_rad)})
      params$y_coord_rotated <- lapply(1:nrow(params), function(n){params$y_coord[[n]]*cos(wdir_rad)-params$x_coord[[n]]*sin(wdir_rad)})
      params$theta <- lapply(1:nrow(params), function(n){atan2(params$y_coord_rotated[[n]], params$x_coord_rotated[[n]])*180.0/pi})

  ## Subset Neighbourhoods based on distances and angles
    # Cells within each neighbourhood are given a value of 1, others are given a value of NA.
      # Note, we avoid issues with atan2 and angle location by hard-coding the centre cell (dist == 0) as part of the neighbourhood. 
      params$hood <- lapply(1:nrow(params), function(n){ifelse((params$dist[[n]] <= params$param_D[[n]] & (abs(params$theta[[n]])-0.1 <= params$param_alpha[[n]]/2.0)) | params$dist[[n]] == 0.0,1,NA)})
      
    # Normalise the value of cells within each neighbourhood based on the total number of cells in that neighbourhood.
      # This effectively means that the inputs being aggregated will be averaged within each neighbourhood.
      params$hood_n <- lapply(1:nrow(params), function(n){params$hood[[n]]/sum(params$hood[[n]],na.rm = T)}) 
    
  #Write each matrix to an output csv file if log_matrix = T:
    if(logmatrix){lapply(1:nrow(params), function(n){write.csv(params$hood_n[[n]], file.path("Log", paste0(n, "_Neighbourhood_matrix.csv")), na = "")})}

### Use Neighbourhoods to aggregate fire behaviour parameters with terra's focal function:

  #Create aggregated versions of the input layer, x, where resolution factor (Rfact) is greater than 1.
    #Note the choice here to use aggregate over resample. Depending on accuracy requirements, may need to upgrade.Resample would be more accurate, but slower.
    neighbourhoods <- NULL
    neighbourhoods$x_ag <- lapply(1:nrow(params), function(n){if(params$param_Rfact[[n]] == 1){x}else{terra::aggregate(x, fact = params$param_Rfact[[n]], fun = "mean")}})

  # Undertake focal function using each input layer, x_ag, (which may have an altered resolution) and each neighbourhood matrix (designed for each layer's resolution).
    # Purposefully keep expand = FALSE, make users enter an edge.value to use where the neighbourhoods cover areas outside of the input layer x. This approach is more fool-proof, demands users think about edge effects.
    neighbourhoods$index <- lapply(1:nrow(params), function(n){terra::focal(neighbourhoods$x_ag[[n]], w = params$hood_n[[n]], fun = "sum", na.rm = T, na.policy = "all", fillvalue = edge.value, expand = FALSE)})

  # Resample back down into resolution of the original inputs:
    neighbourhoods$index_r <- lapply(1:nrow(params), function(n){if(params$param_Rfact[[n]] == 1){neighbourhoods$index[[n]]}else{terra::resample(x = neighbourhoods$index[[n]], y = x, method = "bilinear")}})

  # Transform list of terra SpatRasters to a multi-layered RasterStack to pass back from function:
    NI <- terra::rast(neighbourhoods$index_r[1:nrow(params)])

  # Give meaningful names to each layer
    names(NI) <- paste("D", params$param_D, "alpha", params$param_alpha, "Rfact", params$param_Rfact, sep = "_")

return(NI)
}